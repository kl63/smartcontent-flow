import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { createReadStream, createWriteStream } from 'fs';
import { mkdir } from 'fs/promises';
import { NextRequest } from 'next/server';

// Import the text-to-speech library
// Note: You'll need to install this with: npm install say

// This is a simple mock TTS implementation since we can't install
// packages in this environment. Replace with actual TTS library later.
const generateSpeech = async (text: string, outputPath: string): Promise<void> => {
  try {
    // For demo purposes, we're generating a placeholder audio file
    // In production, you would use say.js, Google Cloud TTS, Amazon Polly, etc.
    
    // For now, we'll create a simple text file that you can manually replace with audio
    await mkdir(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath + '.txt', text);
    
    // Create a placeholder note to explain what's needed
    const placeholderNote = `
      This is a placeholder for the audio file that would be generated by a text-to-speech API.
      The text that would be converted to speech is:
      
      "${text}"
      
      To implement actual TTS, you would need to:
      1. Install a TTS library (e.g., say.js, Google Cloud TTS, Amazon Polly)
      2. Replace this placeholder with actual audio generation code
      3. Use the audio file in your video generation
    `;
    
    fs.writeFileSync(outputPath + '.placeholder.txt', placeholderNote);
    
    // In production, you would have code like this:
    // await say.export(text, 'Microsoft David', 1.0, outputPath);
    
    // For now, copy a sample MP3 file if one exists in the project
    try {
      const samplePath = path.join(process.cwd(), 'public', 'samples', 'sample-speech.mp3');
      const destinationDir = path.dirname(outputPath);
      
      if (fs.existsSync(samplePath)) {
        // Create directory if it doesn't exist
        if (!fs.existsSync(destinationDir)) {
          await mkdir(destinationDir, { recursive: true });
        }
        
        // Copy sample file
        fs.copyFileSync(samplePath, outputPath);
      } else {
        // No sample file - create an empty one to avoid breaking the application
        fs.writeFileSync(outputPath, '');
      }
    } catch (error) {
      console.error('Failed to copy sample audio:', error);
      // Create an empty file to avoid breaking the application
      fs.writeFileSync(outputPath, '');
    }
  } catch (error) {
    console.error('Error in speech generation:', error);
    throw error;
  }
};

export async function POST(req: NextRequest) {
  try {
    // Parse the request body
    const body = await req.json();
    const { text } = body;
    
    if (!text) {
      return NextResponse.json(
        { error: 'Text parameter is required' },
        { status: 400 }
      );
    }
    
    // Generate a unique filename
    const timestamp = Date.now();
    const filename = `speech-${timestamp}.mp3`;
    
    // Create directories in public/audio
    const publicDir = path.join(process.cwd(), 'public');
    const audioDir = path.join(publicDir, 'audio');
    
    if (!fs.existsSync(audioDir)) {
      await mkdir(audioDir, { recursive: true });
    }
    
    // Path to output file
    const outputPath = path.join(audioDir, filename);
    
    // Generate the speech file
    await generateSpeech(text, outputPath);
    
    // Return the URL to the audio file
    return NextResponse.json({ 
      audioUrl: `/audio/${filename}`,
      success: true
    });
  } catch (error) {
    console.error('Error in generate-speech API:', error);
    return NextResponse.json(
      { error: 'Failed to generate speech', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}
